<!DOCTYPE html>
<meta charset="utf8">
<pre class="metadata">
title: Intl era and monthCode Proposal
stage: 2
location: https://tc39.es/proposal-intl-era-monthcode/
copyright: true
contributors: Google, Ecma International
</pre>
<emu-biblio href="biblio.json"></emu-biblio>

<emu-clause id="ecma402-locales-currencies-tz">
  <h1>Identification of Locales, Currencies, Time Zones, Measurement Units, Numbering Systems, Collations, and Calendars</h1>

  <emu-clause id="sec-ecma402-calendar-types" oldids="sec-calendar-types">
    <h1>Calendar Types</h1>

    <emu-note type="editor">
      <p>
        This section, Calendar Types, is <a href="https://tc39.es/ecma402/#sec-calendar-types">present in ECMA-402</a> but is slated to <a href="https://tc39.es/proposal-temporal/#sec-calendar-types">move to ECMA-262 as part of the Temporal proposal</a>.
        This proposal re-adds the section to ECMA-402, but with additional requirements for Intl-supporting implementations, beyond those specified in ECMA-262.
      </p>
    </emu-note>

    <del class="block">
      <p>This specification identifies calendars using a <dfn variants="calendar types">calendar type</dfn> as defined by <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Elements">Unicode Technical Standard #35 Part 4 Dates, Section 2 Calendar Elements</a>. Their canonical form is a string containing only Unicode Basic Latin lowercase letters (U+0061 LATIN SMALL LETTER A through U+007A LATIN SMALL LETTER Z) with zero or more medial hyphens (U+002D HYPHEN-MINUS).</p>
    </del>

    <ins class="block">
      <p>
        ECMA-262 describes calendar types, of which *"iso8601"* is required to be supported.
        This specification additionally requires ECMAScript implementations to support calendar types corresponding with those of the <a href="https://cldr.unicode.org/">Unicode Common Locale Data Repository (CLDR)</a>.
      </p>
    </ins>

    <emu-clause id="sup-availablecalendars" oldids="sec-availablecalendars sec-availablecanonicalcalendars" type="implementation-defined abstract operation">
      <h1>AvailableCalendars ( ): a List of calendar types</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned List is sorted according to lexicographic code unit order, and contains unique calendar types in canonical form (<emu-xref href="#sec-calendar-types"></emu-xref>) identifying the calendars for which the implementation provides the functionality of Intl.DateTimeFormat objects, including their aliases (e.g., <del>either</del> both <del>or neither of</del> *"islamicc"* and *"islamic-civil"*). The List must include <del>*"iso8601"*</del><ins>the Calendar Type value of every row of <emu-xref href="#table-calendar-types"></emu-xref>, except the header row</ins>.</dd>
      </dl>
      <p><ins>This definition supersedes the definition provided in <emu-xref href="#sec-availablecalendars"></emu-xref>.</ins></p>
    </emu-clause>

    <ins class="block">
      <emu-table id="table-calendar-types">
        <emu-caption>Calendar types described in CLDR</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Calendar Type</th>
              <th>Description and implementation notes</th>
            </tr>
          </thead>
          <tr>
            <td>*"buddhist"*</td>
            <td>Thai Buddhist calendar, proleptic. Month numbers, month codes, and days are the same as in the ISO 8601 calendar, but the epoch year is different. There is one era.</td>
          </tr>
          <tr>
            <td>*"chinese"*</td>
            <td>Traditional Chinese calendar, proleptic. Similar lunisolar algorithm to *"dangi"*. The arithmetic year is identical to *"gregory"* and there are no eras.</td>
          </tr>
          <tr>
            <td>*"coptic"*</td>
            <td>Coptic calendar, proleptic. Similar solar algorithm to *"ethioaa"* and *"ethiopic"*, with one era and a different epoch year.</td>
          </tr>
          <tr>
            <td>*"dangi"*</td>
            <td>Traditional Korean calendar, proleptic. Similar lunisolar algorithm to *"chinese"*. The arithmetic year is identical to *"gregory"* and there are no eras.</td>
          </tr>
          <tr>
            <td>*"ethioaa"*</td>
            <td>Ethiopic calendar, Amete Alem, proleptic. Similar solar algorithm to *"coptic"* and *"ethiopic"*, with one era and a different epoch year.</td>
          </tr>
          <tr>
            <td>*"ethiopic"*</td>
            <td>Ethiopic calendar, Amete Mihret, proleptic. Similar solar algorithm to *"coptic"* and *"ethioaa"*, with two eras and a different epoch year.</td>
          </tr>
          <tr>
            <td>*"ethiopic-amete-alem"*</td>
            <td>Alias for *"ethioaa"*.</td>
          </tr>
          <tr>
            <td>*"gregory"*</td>
            <td>Gregorian calendar, proleptic. Solar calendar almost identical to the ISO 8601 calendar, except that it does not define week numbering and it contains two eras, one before the epoch year.</td>
          </tr>
          <tr>
            <td>*"hebrew"*</td>
            <td>Hebrew calendar, proleptic. Lunisolar calendar with one leap month inserted after month 5. There is one era.</td>
          </tr>
          <tr>
            <td>*"indian"*</td>
            <td>Indian national (or ≈öaka) calendar, proleptic. Solar calendar with one era.</td>
          </tr>
          <tr>
            <td>*"islamic-civil"*</td>
            <td>Hijri calendar, proleptic, tabular/rule-based with leap years 2, 5, 7, 10, 13, 16, 18, 21, 24, 26, 29 in the 30-year cycle, and civil epoch (Friday July 16, 622 Julian / 0622-07-19 ISO)</td>
          </tr>
          <tr>
            <td>*"islamic-tbla"*</td>
            <td>Hijri calendar, proleptic, tabular/rule-based with leap years 2, 5, 7, 10, 13, 16, 18, 21, 24, 26, 29 in the 30-year cycle, and astronomical epoch (Thursday July 15, 622 Julian / 0622-07-18 ISO)</td>
          </tr>
          <tr>
            <td>*"islamic-umalqura"*</td>
            <td>Hijri calendar, proleptic, Umm al-Qura. Lunisolar calendar using KACST-calculated months from the start of 1300 AH to the end of 1600 AH and falls back to *"islamic-civil"* outside that range.</td>
          </tr>
          <tr>
            <td>*"islamicc"*</td>
            <td>Deprecated alias for *"islamic-civil"*.</td>
          </tr>
          <tr>
            <td>*"iso8601"*</td>
            <td>ISO 8601 calendar. Fully specified in ECMA-262.</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>Japanese Imperial calendar, era system hybridised with *"gregory"*. Month numbers, month codes, and days are the same as in the ISO 8601 calendar, extended proleptically before their introduction in ISO year 1873. Imperial era names only extend as far back as the Meiji period (starting in ISO year 1868) during which calendar reforms took place. The arithmetic year, and the years and eras before ISO year 1868, are identical to *"gregory"*.</td>
          </tr>
          <tr>
            <td>*"persian"*</td>
            <td>Persian (or Solar Hijri) calendar, proleptic. There is one era.</td>
          </tr>
          <tr>
            <td>*"roc"*</td>
            <td>Republic of China (or Minguo) calendar, proleptic. Month numbers, month codes, and days are the same as in the ISO 8601 calendar, but the epoch year is different. There are two eras, one before the epoch year and one after.</td>
          </tr>
        </table>
      </emu-table>
    </ins>
  </emu-clause>
</emu-clause>

<emu-clause id="locale-and-parameter-negotiation">
  <h1>Locale and Parameter Negotiation</h1>

  <emu-clause id="sec-internal-slots">
    <h1>Internal slots of Service Constructors</h1>

    <p>[...]</p>

    <emu-note>
      For example, an implementation of DateTimeFormat might include the language tag *"fa-IR"* in its [[AvailableLocales]] internal slot, and must (according to <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>) include the keys *"ca"*, *"hc"*, and *"nu"* in its [[RelevantExtensionKeys]] internal slot.
      The default calendar for that locale is usually *"persian"*, but an implementation might also support *"gregory"*<del>, *"islamic"*,</del> and *"islamic-civil"*.
      The Record in the DateTimeFormat [[LocaleData]] internal slot would therefore include a [[fa-IR]] field whose value is a Record like { [[ca]]: ¬´ *"persian"*, *"gregory"*, <del>*"islamic"*,</del> *"islamic-civil"* ¬ª, [[hc]]: ¬´ ‚Ä¶ ¬ª, [[nu]]: ¬´ ‚Ä¶ ¬ª }, along with other locale-named fields having the same value shape but different elements in their Lists.
    </emu-note>
  </emu-clause>
</emu-clause>

<emu-clause id="ecma402-datetimeformat-objects">
  <h1>DateTimeFormat Objects</h1>

  <emu-clause id="sec-ecma402-intl-datetimeformat-constructor">
    <h1>The Intl.DateTimeFormat Constructor</h1>

    <emu-clause id="sec-createdatetimeformat" type="abstract operation" oldids="sec-initializedatetimeformat,sec-todatetimeoptions">
      <h1>
        CreateDateTimeFormat (
          _newTarget_: a constructor,
          _locales_: an ECMAScript language value,
          _options_: an ECMAScript language value,
          _required_: ~date~, ~time~, or ~any~,
          _defaults_: ~date~, ~time~, or ~all~,
        ): either a normal completion containing a DateTimeFormat object or a throw completion
      </h1>

      <dl class="header">
      </dl>

      <emu-alg>
        1. Let _dateTimeFormat_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Intl.DateTimeFormat.prototype%"*, ¬´ [[InitializedDateTimeFormat]], [[Locale]], [[Calendar]], [[NumberingSystem]], [[TimeZone]], [[HourCycle]], [[DateStyle]], [[TimeStyle]], [[DateTimeFormat]], [[BoundFormat]] ¬ª).
        1. Let _hour12_ be *undefined*.
        1. Let _modifyResolutionOptions_ be a new Abstract Closure with parameters (_options_) that captures _hour12_ and performs the following steps when called:
          1. Set _hour12_ to _options_.[[hour12]].
          1. Remove field [[hour12]] from _options_.
          1. If _hour12_ is not *undefined*, set _options_.[[hc]] to *null*.
        1. Let _optionsResolution_ be ? ResolveOptions(%Intl.DateTimeFormat%, %Intl.DateTimeFormat%.[[LocaleData]], _locales_, _options_, ¬´ ~coerce-options~ ¬ª, _modifyResolutionOptions_).
        1. Set _options_ to _optionsResolution_.[[Options]].
        1. Let _r_ be _optionsResolution_.[[ResolvedLocale]].
        1. Set _dateTimeFormat_.[[Locale]] to _r_.[[Locale]].
        1. Let _resolvedCalendar_ be _r_.[[ca]].
        1. <ins>If _resolvedCalendar_ is *"islamic"* or *"islamic-rgsa"*, then</ins>
          1. <ins>Let _fallbackCalendar_ be an implementation- and locale-defined calendar type that is one of the values returned from AvailableCalendars.</ins>
          1. <ins>Set _fallbackCalendar_ to CanonicalizeUValue(*"ca"*, _fallbackCalendar_).</ins>
          1. <ins>Set _resolvedCalendar_ to _fallbackCalendar_.</ins>
        1. Set _dateTimeFormat_.[[Calendar]] to _resolvedCalendar_.
        1. NOTE: Rest of algorithm unchanged.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-ecma402-properties-of-intl-datetimeformat-constructor">
    <h1>Properties of the Intl.DateTimeFormat Constructor</h1>

    <emu-clause id="sec-ecma402-intl.datetimeformat-internal-slots">
      <h1>Internal slots</h1>

      <p>[...]</p>

      <p>The value of the [[LocaleData]] internal slot is implementation-defined within the constraints described in <emu-xref href="#sec-internal-slots"></emu-xref> and the following additional constraints, for all locale values _locale_:</p>

      <ul>
        <li><ins>[[LocaleData]].[[&lt;_locale_>]].[[ca]] must be a List consisting of values from the Calendar Type column of <emu-xref href="#table-calendar-types"></emu-xref>. The list may also include *"islamic"* and *"islamic-rgsa"*.</ins></li>
        <li>
          [[LocaleData]].[[&lt;_locale_>]].[[nu]] must be a List that does not include the values *"native"*, *"traditio"*, or *"finance"*.
        </li>
        <li>
          [[LocaleData]].[[&lt;_locale_>]].[[hc]] must be ¬´ *null*, *"h11"*, *"h12"*, *"h23"*, *"h24"* ¬ª.
        </li>
        <li>[...]</li>
      </ul>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="ecma402-locale-sensitive-functions">
  <h1>Locale Sensitive Functions of the ECMAScript Language Specification</h1>

  <emu-clause id="sec-calendar-abstract-ops">
    <h1>Abstract Operations for Calendar Calculations</h1>

    <emu-clause id="sec-temporal-calendarsupportsera" type="abstract operation">
      <h1>
        CalendarSupportsEra (
          _calendar_: a calendar type,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The following algorithm refers to the era data from <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Data">UTS 35's Supplemental Calendar Data</a>.
        </dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is listed in the Calendar column of <emu-xref href="#table-eras"></emu-xref>, return *true*.
        1. Return *false*.
      </emu-alg>
      <emu-table id="table-eras">
        <emu-caption>era aliases and range of eraYear</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Calendar</th>
              <th>Era</th>
              <th>Aliases</th>
              <th>Minimum eraYear</th>
              <th>Maximum eraYear</th>
            </tr>
          </thead>
          <tr>
            <td>*"buddhist"*</td>
            <td>*"be"*</td>
            <td></td>
            <td>*-‚àû*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"coptic"*</td>
            <td>*"am"*</td>
            <td></td>
            <td>*-‚àû*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"ethiopic"*</td>
            <td>*"am"*</td>
            <td>*"incar"*</td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"ethiopic"*</td>
            <td>*"aa"*</td>
            <td>*"mundi"*</td>
            <td>*-‚àû*<sub>ùîΩ</sub></td>
            <td>*5500*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"ethioaa"*</td>
            <td>*"aa"*</td>
            <td>*"mundi"*</td>
            <td>*-‚àû*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"gregory"*</td>
            <td>*"ce"*</td>
            <td>*"ad"*</td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"gregory"*</td>
            <td>*"bce"*</td>
            <td>*"bc"*</td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"hebrew"*</td>
            <td>*"am"*</td>
            <td></td>
            <td>*-‚àû*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"indian"*</td>
            <td>*"shaka"*</td>
            <td></td>
            <td>*-‚àû*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"islamic-civil"*</td>
            <td>*"ah"*</td>
            <td></td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"islamic-civil"*</td>
            <td>*"bh"*</td>
            <td></td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"islamic-tbla"*</td>
            <td>*"ah"*</td>
            <td></td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"islamic-tbla"*</td>
            <td>*"bh"*</td>
            <td></td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"islamic-umalqura"*</td>
            <td>*"ah"*</td>
            <td></td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"islamic-umalqura"*</td>
            <td>*"bh"*</td>
            <td></td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"reiwa"*</td>
            <td></td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"heisei"*</td>
            <td></td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*31*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"showa"*</td>
            <td></td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*64*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"taisho"*</td>
            <td></td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*15*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"meiji"*</td>
            <td></td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*45*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"ce"*</td>
            <td>*"ad"*</td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*1868*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"bce"*</td>
            <td>*"bc"*</td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"persian"*</td>
            <td>*"ap"*</td>
            <td></td>
            <td>*-‚àû*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"roc"*</td>
            <td>*"roc"*</td>
            <td>*"minguo"*</td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
          <tr>
            <td>*"roc"*</td>
            <td>*"broc"*</td>
            <td>*"before-roc"*, *"minguo-qian"*</td>
            <td>*1*<sub>ùîΩ</sub></td>
            <td>*+‚àû*<sub>ùîΩ</sub></td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-canonicalizeeraincalendar" type="abstract operation">
      <h1>
        CanonicalizeEraInCalendar (
          _calendar_: a calendar type that is not *"iso8601"*,
          _era_: a String,
        ): a String or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The following algorithm refers to the era data from <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Data">UTS 35's Supplemental Calendar Data</a>.
        </dd>
      </dl>
      <emu-alg>
        1. For each row of <emu-xref href="#table-eras"></emu-xref>, do
          1. Let _cal_ be the Calendar value of the current row.
          1. If _cal_ is equal to _calendar_, then
            1. Let _canonicalName_ be the Era value of the current row.
            1. If _canonicalName_ is equal to _era_, return _canonicalName_.
            1. Let _aliases_ be a List whose elements are the strings given in the Aliases column of the row.
            1. If _aliases_ contains _era_, return _canonicalName_.
        1. Return *undefined*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isvalidmonthcodeforcalendar" type="abstract operation">
      <h1>
        IsValidMonthCodeForCalendar (
          _calendar_: a calendar type that is not *"iso8601"*,
          _monthCode_: a String,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _commonMonthCodes_ be ¬´ *"M01"*, *"M02"*, *"M03"*, *"M04"*, *"M05"*, *"M06"*, *"M07"*, *"M08"*, *"M09"*, *"M10"*, *"M11"*, *"M12"* ¬ª.
        1. If _commonMonthCodes_ contains _monthCode_, return *true*.
        1. If _calendar_ is not listed in the Calendar column of <emu-xref href="#table-additional-month-codes"></emu-xref>, return *false*.
        1. Let _r_ be the row in <emu-xref href="#table-additional-month-codes"></emu-xref> which the _calendar_ is in the Calendar column.
        1. Let _specialMonthCodes_ be a List whose elements are the strings given in the *"Additional Month Codes"* column of _r_.
        1. If _specialMonthCodes_ contains _monthCode_, return *true*.
        1. Return *false*.
      </emu-alg>

      <emu-table id="table-additional-month-codes">
        <emu-caption>Additional Month Codes in Calendars</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Calendar</th>
              <th>Additional Month Codes</th>
            </tr>
          </thead>
          <tr>
            <td>*"chinese"*</td>
            <td>*"M01L"*, *"M02L"*, *"M03L"*, *"M04L"*, *"M05L"*, *"M06L"*, *"M07L"*, *"M08L"*, *"M09L"*, *"M10L"*, *"M11L"*, *"M12L"*</td>
          </tr>
          <tr>
            <td>*"coptic"*</td>
            <td>*"M13"*</td>
          </tr>
          <tr>
            <td>*"dangi"*</td>
            <td>*"M01L"*, *"M02L"*, *"M03L"*, *"M04L"*, *"M05L"*, *"M06L"*, *"M07L"*, *"M08L"*, *"M09L"*, *"M10L"*, *"M11L"*, *"M12L"*</td>
          </tr>
          <tr>
            <td>*"ethiopic"*</td>
            <td>*"M13"*</td>
          </tr>
          <tr>
            <td>*"ethioaa"*</td>
            <td>*"M13"*</td>
          </tr>
          <tr>
            <td>*"hebrew"*</td>
            <td>*"M05L"*</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-isvaliderayearforcalendar" type="abstract operation">
      <h1>
        IsValidEraYearForCalendar (
          _calendar_: a calendar type that is not *"iso8601"*,
          _era_: a String,
          _eraYear_: an integer,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The following algorithm refers to the era data from <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Data">UTS 35's Supplemental Calendar Data</a>.
        </dd>
      </dl>
      <emu-alg>
        1. Let _era_ be CanonicalizeEraInCalendar(_calendar_, _era_).
        1. If _era_ is *undefined*, return *false*.
        1. Let _r_ be the row in <emu-xref href="#table-eras"></emu-xref> in which _calendar_ is in the Calendar column and _era_ is in the Era column.
        1. Let _min_ be the value given in the *"Minimum eraYear"* column of _r_.
        1. Let _max_ be the value given in the *"Maximum eraYear"* column of _r_.
        1. If _eraYear_ &lt; _min_, return *false*.
        1. If _eraYear_ > _max_, return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateera" type="abstract operation">
      <h1>
        CalendarDateEra (
          _calendar_: a calendar type that is not *"iso8601"*,
          _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): a String or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the era for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns a lowercase String value representing that era, or *undefined* for calendars that do not have eras.</dd>
      </dl>
      <emu-alg>
        1. If CalendarSupportsEra(_calendar_) is *false*, return *undefined*.
        1. Let _era_ be the String to indicate the era corresponding to _date_ in the context of the calendar represented by _calendar_ from an implementation-defined processing.
        1. Return CanonicalizeEraInCalendar(_calendar_, _era_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateerayear" type="abstract operation">
      <h1>
        CalendarDateEraYear (
          _calendar_: a calendar type that is not *"iso8601"*,
          _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): an integer or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the era for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns an integer representing the ordinal position of the year of _date_ in that era, or *undefined* for calendars that do not have eras.</dd>
      </dl>
      </dl>
      <emu-alg>
        1. If CalendarSupportsEra(_calendar_) is *false*, return *undefined*.
        1. Let _eraYear_ be the integer to indicate the era year corresponding to _date_ in the context of the calendar represented by _calendar_ from an implementation-defined processing.
        1. Assert: _eraYear_ is an integer.
        1. Return _eraYear_.
      </emu-alg>
      <emu-note>
        Era years are 1-indexed for many calendars, but not all (e.g., the eras of the Burmese calendar each start with a year 0). Years can also advance opposite the flow of time (as for BCE years in the Gregorian calendar).
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatearithmeticyear" type="abstract operation">
      <h1>
        CalendarDateArithmeticYear (
          _calendar_: a calendar type that is not *"iso8601"*,
          _date_: a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the year for the date corresponding to _date_ in the context of the calendar represented by _calendar_ relative to a well-defined epoch year for that calendar.</dd>
      </dl>
      <emu-alg>
        1. Let _year_ be _date_.[[ISOYear]].
        1. Let _r_ be the row in <emu-xref href="#table-epoch-years"></emu-xref> which the value of the Calendar column is _calendar_.
        1. Let _epochYear_ be the value given in the *"Epoch ISO Year"* column of _r_.
        1. Let _arithmeticYear_ be the number of whole years in the calendar represented by _calendar_ elapsed until the ISO year _year_ since the calendar year that started during ISO year _epochYear_, according to implementation-defined processing.
        1. Return _arithmeticYear_.
      </emu-alg>

      <emu-table id="table-epoch-years">
        <emu-caption>epoch years</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Calendar</th>
              <th>Epoch ISO Year</th>
            </tr>
          </thead>
          <tr>
            <td>*"buddhist"*</td>
            <td>-543</td>
          </tr>
          <tr>
            <td>*"chinese"*</td>
            <td>0</td>
          </tr>
          <tr>
            <td>*"coptic"*</td>
            <td>283</td>
          </tr>
          <tr>
            <td>*"dangi"*</td>
            <td>0</td>
          </tr>
          <tr>
            <td>*"ethiopic"*</td>
            <td>7</td>
          </tr>
          <tr>
            <td>*"ethioaa"*</td>
            <td>-5492</td>
          </tr>
          <tr>
            <td>*"gregory"*</td>
            <td>0</td>
          </tr>
          <tr>
            <td>*"hebrew"*</td>
            <td>-3761</td>
          </tr>
          <tr>
            <td>*"indian"*</td>
            <td>78</td>
          </tr>
          <tr>
            <td>*"islamic-civil"*</td>
            <td>621</td>
          </tr>
          <tr>
            <td>*"islamic-tbla"*</td>
            <td>621</td>
          </tr>
          <tr>
            <td>*"islamic-umalqura"*</td>
            <td>621</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>0</td>
          </tr>
          <tr>
            <td>*"persian"*</td>
            <td>621</td>
          </tr>
          <tr>
            <td>*"roc"*</td>
            <td>1911</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sup-temporal-calendar-date-records">
      <h1>Calendar Date Records</h1>
      <p>
        A <dfn variants="Calendar Date Records">Calendar Date Record</dfn> is a Record value used to represent a valid calendar date in a non-ISO 8601 calendar.
        Calendar Date Records are produced by the abstract operation CalendarISOToDate.
      </p>
      <p>Calendar Date Records have the fields listed in <emu-xref href="#table-temporal-calendar-date-record-fields"></emu-xref>.</p>
      <p>This definition supersedes the one in <emu-xref href="#sec-temporal-calendar-date-records"></emu-xref>.</p>
      <emu-table id="table-temporal-calendar-date-record-fields" caption="Calendar Date Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Era]]</td>
            <td>a String or *undefined*</td>
            <td>
              A lowercase String value representing the date's era, or *undefined* for calendars that do not have eras.<br>
              The value of this field for a calendar type _calendar_ should be the result of calling CalendarDateEra(_calendar_, _date_), where _date_ is a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth value corresponding to the date.
            </td>
          </tr>
          <tr>
            <td>[[EraYear]]</td>
            <td>an integer or *undefined*</td>
            <td>
              The ordinal position of the date's year within its era, or *undefined* for calendars that do not have eras.<br>
              The value of this field for a calendar type _calendar_ should be the result of calling CalendarDateEraYear(_calendar_, _date_), where _date_ is a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth value corresponding to the date.
              <emu-note>
                Era years are 1-indexed for many calendars, but not all (e.g., the eras of the Burmese calendar each start with a year 0). Years can also advance opposite the flow of time (as for BCE years in the Gregorian calendar).
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[Year]]</td>
            <td>an integer</td>
            <td>
              The date's year relative to the first day of a calendar-specific "epoch year".<br>
              The value of this field for a calendar type _calendar_ should be the result of calling CalendarDateArithmeticYear(_calendar_, _date_), where _date_ is a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth value corresponding to the date.
              <emu-note>The year is relative to the first day of the calendar's epoch year, so if the epoch era starts in the middle of the year, the year will be the same value before and after the start date of the era.</emu-note>
            </td>
          </tr>
          <tr>
            <td>[[Month]]</td>
            <td>a positive integer</td>
            <td>
              The 1-based ordinal position of the date's month within its year.
              <emu-note>
                When the number of months in a year of the calendar is variable, a different value can be returned for dates that are part of the same month in different years. For example, in the Hebrew calendar, 1 Nisan 5781 is associated with value 7 while 1 Nisan 5782 is associated with value 8 because 5782 is a leap year and Nisan follows the insertion of Adar I.
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[MonthCode]]</td>
            <td>a String</td>
            <td>
              The month code of the date's month. The month code for a month that is not a leap month and whose 1-based ordinal position in a common year of the calendar (i.e., a year that is not a leap year) is _n_ should be the string-concatenation of *"M"* and ToZeroPaddedDecimalString(_n_, 2), and the month code for a month that is a leap month inserted after a month whose 1-based ordinal position in a common year of the calendar is _p_ should be the string-concatenation of *"M"*, ToZeroPaddedDecimalString(_p_, 2), and *"L"*.
              <emu-note>
                For example, in the Hebrew calendar, the month code of Adar (and Adar II, in leap years) is *"M06"* and the month code of Adar I (the leap month inserted before Adar II) is *"M05L"*. In a calendar with a leap month at the start of some years, the month code of that month would be *"M00L"*.
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[Day]]</td>
            <td>a positive integer</td>
            <td>
              The 1-based ordinal position of the date's day within its month.
            </td>
          </tr>
          <tr>
            <td>[[DayOfWeek]]</td>
            <td>a positive integer</td>
            <td>
              The day of the week corresponding to the date. The value should be 1-based, where 1 is the day corresponding to Monday in the given calendar.
            </td>
          </tr>
          <tr>
            <td>[[DayOfYear]]</td>
            <td>a positive integer</td>
            <td>
              The 1-based ordinal position of the date's day within its year.
            </td>
          </tr>
          <tr>
            <td>[[WeekOfYear]]</td>
            <td>a Year-Week Record</td>
            <td>
              <p>The date's <em>calendar week of year</em>, and the corresponding <em>week calendar year</em>.</p>
              <p>The Year-Week Record's [[Week]] field should be 1-based.</p>
              <p>The Year-Week Record's [[Year]] field is relative to the first day of a calendar-specific "epoch year", as in the Calendar Date Record's [[Year]] field, not relative to an era as in [[EraYear]].</p>
              <p>
                Usually the Year-Week Record's [[Year]] field will contain the same value as the Calendar Date Record's [[Year]] field, but may contain the previous or next year if the week number in the Year-Week Record's [[Week]] field overlaps two different years.
                See also ISOWeekOfYear.
              </p>
              <p>The Year-Week Record contains *undefined* in [[Week]] and [[Year]] field for calendars that do not have a well-defined week numbering system.</p>
              <emu-note>
                Currently, of the calendars supported in this specification, only *"iso8601"* has a well-defined, locale-independent week numbering system.
                For all other calendars, the Year-Week Record fields are *undefined*.
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[DaysInWeek]]</td>
            <td>a positive integer</td>
            <td>The number of days in the date's week.</td>
          </tr>
          <tr>
            <td>[[DaysInMonth]]</td>
            <td>a positive integer</td>
            <td>The number of days in the date's month.</td>
          </tr>
          <tr>
            <td>[[DaysInYear]]</td>
            <td>a positive integer</td>
            <td>The number of days in the date's year.</td>
          </tr>
          <tr>
            <td>[[MonthsInYear]]</td>
            <td>a positive integer</td>
            <td>The number of months in the date's year.</td>
          </tr>
          <tr>
            <td>[[InLeapYear]]</td>
            <td>a Boolean</td>
            <td>
              *true* if the date falls within a leap year, and *false* otherwise.
              <emu-note>
                A "leap year" is a year that contains more days than other years (for solar or lunar calendars) or more months than other years (for lunisolar calendars like Hebrew or Chinese).
                Some calendars, especially lunisolar ones, have further variation in year length that is not represented in the output of this operation (e.g., the Hebrew calendar includes common years with 353, 354, or 355 days and leap years with 383, 384, or 385 days).
              </emu-note>
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sup-temporal-calendardateadd" type="implementation-defined abstract operation">
      <h1>
        CalendarDateAdd (
          _calendar_: a calendar type,
          _isoDate_: an ISO Date Record,
          _duration_: a Date Duration Record,
          _overflow_: ~constrain~ or ~reject~,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It adds _dateDuration_ to _isoDate_ using the years, months, and weeks reckoning of _calendar_.
          If addition of years or months results in a nonexistent date, depending on _overflow_ it will be coerced to an existing date or the operation will throw.
        </dd>
      </dl>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal-calendardateadd"></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. Let _intermediate_ be BalanceISOYearMonth(_isoDate_.[[Year]] + _duration_.[[Years]], _isoDate_.[[Month]] + _duration_.[[Months]]).
          1. Set _intermediate_ to ? RegulateISODate(_intermediate_.[[Year]], _intermediate_.[[Month]], _isoDate_.[[Day]], _overflow_).
          1. Let _d_ be _intermediate_.[[Day]] + _duration_.[[Days]] + 7 √ó _duration_.[[Weeks]].
          1. Let _result_ be BalanceISODate(_intermediate_.[[Year]], _intermediate_.[[Month]], _d_).
        1. Else,
          1. NOTE: The algorithm when _calendar_ is not *"iso8601"* is implementation-defined, but all calendars follow the general steps given here, which is a generalization of the precise algorithm specified above for *"iso8601"*.
          1. Let _calendarDate_ be CalendarISOToDate(_calendar_, _isoDate_).
          1. Add _duration_.[[Years]] to _calendarDate_.
          1. (This step only matters for lunisolar calendars.) If _calendarDate_.[[MonthCode]] is a leap month that doesn't exist in the year, then:
            1. If _overflow_ is ~reject~, throw a *RangeError* exception.
            1. Set _calendarDate_ to another date according to the cultural conventions of that calendar's users. Of the currently supported calendars: if _calendar_ is *"chinese"* or *"dangi"*, change _calendarDate_.[[MonthCode]] to the same month code but without the *"L"*. If _calendar_ is *"hebrew"*, change _calendarDate_.[[MonthCode]] from *"M05L"* to *"M06"*.
            1. Update _calendarDate_.[[Month]] accordingly.
          1. Add _duration_.[[Months]] to _calendarDate_, balancing _calendarDate_ if it goes over a year boundary.
          1. If the date described by _calendarDate_ does not exist, then
            1. If _overflow_ is ~reject~, throw a *RangeError* exception.
            1. If _calendarDate_.[[MonthCode]] is a valid month code for _calendarDate_.[[Year]], but the date described by _calendarDate_ does not exist, set _calendarDate_.[[Day]] to the closest day in the same month. If there are two equally-close dates in the same month, pick the later one.
            1. (This step does not apply to any currently supported calendars.) If the date described by _calendarDate_ still does not exist, set _calendarDate_ to the closest date in the same year. If there are two equally-close dates in that year, pick the later one.
          1. Add _duration_.[[Weeks]] and _duration_.[[Days]] to _calendarDate_, balancing _calendarDate_ if it goes over a month or year boundary.
          1. Let _result_ be ? CalendarDateToISO(_calendar_, _calendarDate_, _overflow_).
        1. If ISODateWithinLimits(_result_) is *false*, throw a *RangeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-temporal-calendardateuntil" type="implementation-defined abstract operation">
      <h1>
        CalendarDateUntil (
          _calendar_: a calendar type,
          _one_: an ISO Date Record,
          _two_: an ISO Date Record,
          _largestUnit_: a date unit,
        ): a Date Duration Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines the difference between the dates _one_ and _two_ using the years, months, and weeks reckoning of _calendar_.
          No fields larger than _largestUnit_ will be non-zero in the resulting Date Duration Record.
        </dd>
      </dl>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal-calendardateuntil"></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. Let _sign_ be -CompareISODate(_one_, _two_).
          1. If _sign_ = 0, return ZeroDateDuration().
          1. Let _years_ be 0.
          1. If _largestUnit_ is ~year~, then
            1. Let _candidateYears_ be _sign_.
            1. Repeat, while ISODateSurpasses(_sign_, _one_.[[Year]] + _candidateYears_, _one_.[[Month]], _one_.[[Day]], _two_) is *false*,
              1. Set _years_ to _candidateYears_.
              1. Set _candidateYears_ to _candidateYears_ + _sign_.
          1. Let _months_ be 0.
          1. If _largestUnit_ is ~year~ or _largestUnit_ is ~month~, then
            1. Let _candidateMonths_ be _sign_.
            1. Let _intermediate_ be BalanceISOYearMonth(_one_.[[Year]] + _years_, _one_.[[Month]] + _candidateMonths_).
            1. Repeat, while ISODateSurpasses(_sign_, _intermediate_.[[Year]], _intermediate_.[[Month]], _one_.[[Day]], _two_) is *false*,
              1. Set _months_ to _candidateMonths_.
              1. Set _candidateMonths_ to _candidateMonths_ + _sign_.
              1. Set _intermediate_ to BalanceISOYearMonth(_intermediate_.[[Year]], _intermediate_.[[Month]] + _sign_).
          1. Set _intermediate_ to BalanceISOYearMonth(_one_.[[Year]] + _years_, _one_.[[Month]] + _months_).
          1. Let _constrained_ be ! RegulateISODate(_intermediate_.[[Year]], _intermediate_.[[Month]], _one_.[[Day]], ~constrain~).
          1. Let _weeks_ be 0.
          1. If _largestUnit_ is ~week~, then
            1. Let _candidateWeeks_ be _sign_.
            1. Set _intermediate_ to BalanceISODate(_constrained_.[[Year]], _constrained_.[[Month]], _constrained_.[[Day]] + 7 √ó _candidateWeeks_).
            1. Repeat, while ISODateSurpasses(_sign_, _intermediate_.[[Year]], _intermediate_.[[Month]], _intermediate_.[[Day]], _two_) is *false*,
              1. Set _weeks_ to _candidateWeeks_.
              1. Set _candidateWeeks_ to _candidateWeeks_ + sign.
              1. Set _intermediate_ to BalanceISODate(_intermediate_.[[Year]], _intermediate_.[[Month]], _intermediate_.[[Day]] + 7 √ó _sign_).
          1. Let _days_ be 0.
          1. Let _candidateDays_ be _sign_.
          1. Set _intermediate_ to BalanceISODate(_constrained_.[[Year]], _constrained_.[[Month]], _constrained_.[[Day]] + 7 √ó _weeks_ + _candidateDays_).
          1. Repeat, while ISODateSurpasses(_sign_, _intermediate_.[[Year]], _intermediate_.[[Month]], _intermediate_.[[Day]], _two_) is *false*,
            1. Set _days_ to _candidateDays_.
            1. Set _candidateDays_ to _candidateDays_ + _sign_.
            1. Set _intermediate_ to BalanceISODate(_intermediate_.[[Year]], _intermediate_.[[Month]], _intermediate_.[[Day]] + _sign_).
          1. Return ! CreateDateDurationRecord(_years_, _months_, _weeks_, _days_).
        1. NOTE: The algorithm when _calendar_ is not *"iso8601"* is implementation-defined, but all calendars follow the general steps given here, which is a generalization of the precise algorithm specified above for *"iso8601"*.
        1. If _largestUnit_ is ~year~, then
          1. Add (without constraining) as many years as possible to _one_, in the direction from _one_ to _two_, without surpassing _two_. "Surpassing" here (and in all steps below) means to compare years numerically, then month codes lexicographically, then days numerically; if any of them exceed _two_ in the direction from _one_ to _two_, then _two_ is surpassed.
          1. Constrain _one_ to a real year and month, not taking day into account. This step only matters for lunisolar calendars.
        1. If _largestUnit_ is ~year~ or ~month~, then
          1. Add (without constraining) as many months as possible to _one_ without surpassing _two_.
          1. Constrain _one_ to a real year, month, and day.
        1. If _largestUnit_ is ~week~, add as many weeks as possible to _one_ without surpassing _two_.
        1. Add as many days as possible to _one_ until it is equal to _two_.
        1. Return a Date Duration Record of the number of years, months, weeks, and days added.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-temporal-calendardatetoiso" type="implementation-defined abstract operation">
      <h1>
        CalendarDateToISO (
          _calendar_: a calendar type,
          _fields_: a Calendar Fields Record,
          _overflow_: ~constrain~ or ~reject~,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to convert _fields_, which represents either a date or a year and month in the built-in calendar identified by _calendar_, to a corresponding representative date in the ISO 8601 calendar, subject to overflow correction specified by _overflow_.
          For ~reject~, values that do not form a valid date cause an exception to be thrown, as described below.
          For ~constrain~, values that do not form a valid date are clamped to their respective valid range.
        </dd>
      </dl>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal-calendardatetoiso"></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. If _calendar_ is *"iso8601"*, then
          1. Assert: _fields_.[[Year]], _fields_.[[Month]], and _fields_.[[Day]] are not ~unset~.
          1. Return ? RegulateISODate(_fields_.[[Year]], _fields_.[[Month]], _fields_.[[Day]], _overflow_).
        1. NOTE: The algorithm when _calendar_ is not *"iso8601"* is implementation-defined, but all calendars follow the general steps given here, which is a generalization of the precise algorithm specified above for *"iso8601"*.
        1. If _fields_.[[Era]] and _fields_.[[EraYear]] are not ~unset~ and IsValidEraYearForCalendar(_calendar_, _fields_.[[Era]], _fields_.[[EraYear]]) is *false*, throw a *RangeError* exception.
        1. If _fields_.[[MonthCode]] is not ~unset~ and IsValidMonthCodeForCalendar(_calendar_, _fields_.[[MonthCode]]) is *false*, throw a *RangeError* exception.
        1. If _fields_ describes an existing date in _calendar_, return an implementation-defined ISO Date Record that corresponds to the date described by _fields_.
        1. If _overflow_ is ~reject~, throw a *RangeError* exception.
        1. (This step only matters for lunisolar calendars.) If _fields_.[[MonthCode]] is a leap month that doesn't exist in the year, then:
          1. Set _fields_ to another date according to the cultural conventions of that calendar's users. Of the currently supported calendars: if _calendar_ is *"chinese"* or *"dangi"*, change _fields_.[[MonthCode]] to the same month code but without the *"L"*. If _calendar_ is *"hebrew"*, change _fields_.[[MonthCode]] from *"M05L"* to *"M06"*.
          1. Update _fields_.[[Month]] accordingly.
        1. If _fields_.[[MonthCode]] is a valid month code for _fields_.[[Year]], but the date described by _fields_ does not exist, set _fields_.[[Day]] to the closest day in the same month. If there are two equally-close dates in the same month, pick the later one.
        1. (This step does not apply to any currently supported calendars.) If the date described by _fields_ still does not exist, set _fields_ to the closest date in the same year. If there are two equally-close dates in that year, pick the later one.
        1. Return an implementation-defined ISO Date Record that corresponds to the date described by _fields_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-temporal-calendarextrafields" type="implementation-defined abstract operation">
      <h1>
        CalendarExtraFields (
          _calendar_: a calendar type,
          _fields_: a List of values from the Enumeration Key column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>,
        ): a List of values from the Enumeration Key column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It characterizes calendar-specific fields that are relevant for the provided _fields_ in the built-in calendar identified by _calendar_.</dd>
      </dl>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal-calendarextrafields"></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. If _fields_ contains an element equal to ~year~ and CalendarSupportsEra(_calendar_) is *true*, then
          1. Append ~era~ and ~era-year~ to _fields_.
        1. Return _fields_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-temporal-calendarfieldkeystoignore" type="implementation-defined abstract operation">
      <h1>
        CalendarFieldKeysToIgnore (
          _calendar_: a calendar type,
          _keys_: a List of values from the Enumeration Key column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>,
        ): a List of values from the Enumeration Key column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It determines which calendar date fields changing any of the fields named in _keys_ can potentially conflict with or invalidate, for the given _calendar_.
          A field always invalidates at least itself.
        </dd>
      </dl>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal-calendarfieldkeystoignore"></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _ignoredKeys_ be an empty List.
        1. For each element _key_ of _keys_, do
          1. If _key_ is ~month~, append ~month-code~ to _ignoredKeys_.
          1. Else if _key_ is ~month-code~, append ~month~ to _ignoredKeys_.
          1. If _key_ is one of ~era~, ~era-year~, or ~year~ and CalendarSupportsEra(_calendar_) is *true*, then
            1. Append ~era~, ~era-year~, and ~year~ to _ignoredKeys_.
          1. Else,
            1. Append _key_ to _ignoredKeys_.
        1. NOTE: While _ignoredKeys_ can have duplicate elements, this is not intended to be meaningful. This specification only checks whether particular keys are or are not members of the list.
        1. Return _ignoredKeys_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
