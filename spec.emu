<!DOCTYPE html>
<meta charset="utf8">
<pre class="metadata">
title: Intl era and monthCode Proposal
stage: 2
location: https://tc39.es/proposal-intl-era-monthcode/
copyright: true
contributors: Google, Ecma International
</pre>
<emu-biblio href="biblio.json"></emu-biblio>

<emu-clause id="ecma402-locales-currencies-tz">
  <h1>Identification of Locales, Currencies, Time Zones, Measurement Units, Numbering Systems, Collations, and Calendars</h1>

  <emu-clause id="sec-ecma402-calendar-types" oldids="sec-calendar-types">
    <h1>Calendar Types</h1>

    <emu-note type="editor">
      <p>
        This section, Calendar Types, is <a href="https://tc39.es/ecma402/#sec-calendar-types">present in ECMA-402</a> but is slated to <a href="https://tc39.es/proposal-temporal/#sec-calendar-types">move to ECMA-262 as part of the Temporal proposal</a>.
        This proposal re-adds the section to ECMA-402, but with additional requirements for Intl-supporting implementations, beyond those specified in ECMA-262.
      </p>
    </emu-note>

    <del class="block">
      <p>This specification identifies calendars using a <dfn variants="calendar types">calendar type</dfn> as defined by <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Elements">Unicode Technical Standard #35 Part 4 Dates, Section 2 Calendar Elements</a>. Their canonical form is a string containing only Unicode Basic Latin lowercase letters (U+0061 LATIN SMALL LETTER A through U+007A LATIN SMALL LETTER Z) with zero or more medial hyphens (U+002D HYPHEN-MINUS).</p>
    </del>

    <ins class="block">
      <p>
        ECMA-262 describes calendar types, of which *"iso8601"* is required to be supported.
        This specification additionally requires ECMAScript implementations to support calendar types corresponding with those of the <a href="https://cldr.unicode.org/">Unicode Common Locale Data Repository (CLDR)</a>.
      </p>
    </ins>

    <emu-clause id="sup-availablecalendars" oldids="sec-availablecalendars sec-availablecanonicalcalendars" type="implementation-defined abstract operation">
      <h1>AvailableCalendars ( ): a List of calendar types</h1>
      <dl class="header">
        <dt>description</dt>
        <dd>The returned List is sorted according to lexicographic code unit order, and contains unique calendar types in canonical form (<emu-xref href="#sec-calendar-types"></emu-xref>) identifying the calendars for which the implementation provides the functionality of Intl.DateTimeFormat objects, including their aliases (e.g., <del>either</del> both <del>or neither of</del> *"islamicc"* and *"islamic-civil"*). The List must include <del>*"iso8601"*</del><ins>the "Calendar Type" value of every row of <emu-xref href="#table-calendar-types"></emu-xref>, except the header row</ins>.</dd>
      </dl>
      <p><ins>This definition supersedes the definition provided in <emu-xref href="#sec-availablecalendars"></emu-xref>.</ins></p>
    </emu-clause>

    <ins class="block">
      <emu-table id="table-calendar-types">
        <emu-caption>Calendar types described in CLDR</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Calendar Type</th>
              <th>Description and implementation notes</th>
            </tr>
          </thead>
          <tr>
            <td>*"buddhist"*</td>
            <td>Thai Buddhist calendar, proleptic. Month numbers, month codes, and days are identical to ISO 8601, but the epoch year differs. All years are treated as having 12 months. For compatibility with other systems, dates prior to ISO year 1941 (2484 BE) are defined but may not correspond to historically accurate values due to the calendar reforms of 1940 and earlier. There is one era.</td>
          </tr>
          <tr>
            <td>*"chinese"*</td>
            <td>Traditional Chinese calendar, proleptic. Lunisolar calendar used in China based on data published by the Purple Mountain Observatory between 1900 and 2100 (which compiles with GB/T 33661-2017 between 1912 and 2100), falling back to an implementation-defined approximation outside that range. The arithmetic year is identical to *"gregory"*, and there are no eras.</td>
          </tr>
          <tr>
            <td>*"coptic"*</td>
            <td>Coptic calendar, proleptic. Similar solar algorithm to *"ethioaa"* and *"ethiopic"*, with one era and a different epoch year.</td>
          </tr>
          <tr>
            <td>*"dangi"*</td>
            <td>Traditional Korean calendar, proleptic. Lunisolar calendar using months published by the Korea Astronomy and Space Science Institute (KASI) between 1900 and 2050, falling back to an implementation-defined approximation outside that range. The arithmetic year is identical to *"gregory"*, and there are no eras.</td>
          </tr>
          <tr>
            <td>*"ethioaa"*</td>
            <td>Ethiopic calendar, Amete Alem, proleptic. Similar solar algorithm to *"coptic"* and *"ethiopic"*, with one era and a different epoch year.</td>
          </tr>
          <tr>
            <td>*"ethiopic"*</td>
            <td>Ethiopic calendar, Amete Mihret, proleptic. Similar solar algorithm to *"coptic"* and *"ethioaa"*, with two eras and a different epoch year.</td>
          </tr>
          <tr>
            <td>*"ethiopic-amete-alem"*</td>
            <td>Alias for *"ethioaa"*.</td>
          </tr>
          <tr>
            <td>*"gregory"*</td>
            <td>Gregorian calendar, proleptic. Solar calendar almost identical to the ISO 8601 calendar, except that it does not define week numbering and it contains two eras, one before the epoch year.</td>
          </tr>
          <tr>
            <td>*"hebrew"*</td>
            <td>Hebrew calendar, proleptic. Civil calendar with Tishrei as the first month of the year. Lunisolar calendar with one leap month inserted after month 5. There is one era.</td>
          </tr>
          <tr>
            <td>*"indian"*</td>
            <td>Indian national (or Śaka) calendar, proleptic. Solar calendar with one era.</td>
          </tr>
          <tr>
            <td>*"islamic-civil"*</td>
            <td>Hijri calendar, proleptic, tabular/rule-based with leap years 2, 5, 7, 10, 13, 16, 18, 21, 24, 26, 29 in the 30-year cycle, and civil epoch (Friday July 16, 622 Julian / 0622-07-19 ISO)</td>
          </tr>
          <tr>
            <td>*"islamic-tbla"*</td>
            <td>Hijri calendar, proleptic, tabular/rule-based with leap years 2, 5, 7, 10, 13, 16, 18, 21, 24, 26, 29 in the 30-year cycle, and astronomical epoch (Thursday July 15, 622 Julian / 0622-07-18 ISO)</td>
          </tr>
          <tr>
            <td>*"islamic-umalqura"*</td>
            <td>Hijri calendar, proleptic, Umm al-Qura. Lunar calendar using KACST-calculated months from the start of 1300 AH to the end of 1600 AH, falling back to *"islamic-civil"* outside that range.</td>
          </tr>
          <tr>
            <td>*"islamicc"*</td>
            <td>Alias for *"islamic-civil"*.</td>
          </tr>
          <tr>
            <td>*"iso8601"*</td>
            <td>ISO 8601 calendar. Fully specified in ECMA-262.</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>Japanese Imperial calendar, era system hybridised with *"gregory"*. Month numbers, month codes, and days are the same as in the ISO 8601 calendar, extended proleptically before their introduction in ISO year 1873. Imperial era names only extend as far back as the Meiji period (starting in ISO year 1868) during which calendar reforms took place. All era ranges are defined by the Japanese government. The arithmetic year, and the years and eras before ISO year 1868, are identical to *"gregory"*.</td>
          </tr>
          <tr>
            <td>*"persian"*</td>
            <td>Persian (or Solar Hijri) calendar, proleptic. There is one era.</td>
          </tr>
          <tr>
            <td>*"roc"*</td>
            <td>Republic of China (or Minguo) calendar, proleptic. Month numbers, month codes, and days are the same as in the ISO 8601 calendar, but the epoch year is different. There are two eras, one before the epoch year and one after.</td>
          </tr>
        </table>
      </emu-table>
    </ins>
  </emu-clause>
</emu-clause>

<emu-clause id="locale-and-parameter-negotiation">
  <h1>Locale and Parameter Negotiation</h1>

  <emu-clause id="sec-internal-slots">
    <h1>Internal slots of Service Constructors</h1>

    <p>[...]</p>

    <emu-note>
      For example, an implementation of DateTimeFormat might include the language tag *"fa-IR"* in its [[AvailableLocales]] internal slot, and must (according to <emu-xref href="#sec-intl.datetimeformat-internal-slots"></emu-xref>) include the keys *"ca"*, *"hc"*, and *"nu"* in its [[RelevantExtensionKeys]] internal slot.
      The default calendar for that locale is usually *"persian"*, but an implementation might also support *"gregory"*<del>, *"islamic"*,</del> and *"islamic-civil"*.
      The Record in the DateTimeFormat [[LocaleData]] internal slot would therefore include a [[fa-IR]] field whose value is a Record like { [[ca]]: « *"persian"*, *"gregory"*, <del>*"islamic"*,</del> *"islamic-civil"* », [[hc]]: « … », [[nu]]: « … » }, along with other locale-named fields having the same value shape but different elements in their Lists.
    </emu-note>
  </emu-clause>
</emu-clause>

<emu-clause id="ecma402-datetimeformat-objects">
  <h1>DateTimeFormat Objects</h1>

  <emu-clause id="sec-ecma402-intl-datetimeformat-constructor">
    <h1>The Intl.DateTimeFormat Constructor</h1>

    <emu-clause id="sec-createdatetimeformat" type="abstract operation" oldids="sec-initializedatetimeformat,sec-todatetimeoptions">
      <h1>
        CreateDateTimeFormat (
          _newTarget_: a constructor,
          _locales_: an ECMAScript language value,
          _options_: an ECMAScript language value,
          _required_: ~date~, ~time~, or ~any~,
          _defaults_: ~date~, ~time~, or ~all~,
        ): either a normal completion containing a DateTimeFormat object or a throw completion
      </h1>

      <dl class="header">
      </dl>

      <emu-alg>
        1. Let _dateTimeFormat_ be ? OrdinaryCreateFromConstructor(_newTarget_, *"%Intl.DateTimeFormat.prototype%"*, « [[InitializedDateTimeFormat]], [[Locale]], [[Calendar]], [[NumberingSystem]], [[TimeZone]], [[HourCycle]], [[DateStyle]], [[TimeStyle]], [[DateTimeFormat]], [[BoundFormat]] »).
        1. Let _hour12_ be *undefined*.
        1. Let _modifyResolutionOptions_ be a new Abstract Closure with parameters (_options_) that captures _hour12_ and performs the following steps when called:
          1. Set _hour12_ to _options_.[[hour12]].
          1. Remove field [[hour12]] from _options_.
          1. If _hour12_ is not *undefined*, set _options_.[[hc]] to *null*.
        1. Let _optionsResolution_ be ? ResolveOptions(%Intl.DateTimeFormat%, %Intl.DateTimeFormat%.[[LocaleData]], _locales_, _options_, « ~coerce-options~ », _modifyResolutionOptions_).
        1. Set _options_ to _optionsResolution_.[[Options]].
        1. Let _r_ be _optionsResolution_.[[ResolvedLocale]].
        1. Set _dateTimeFormat_.[[Locale]] to _r_.[[Locale]].
        1. Let _resolvedCalendar_ be _r_.[[ca]].
        1. <ins>If _resolvedCalendar_ is *"islamic"* or *"islamic-rgsa"*, then</ins>
          1. <ins>Let _fallbackCalendar_ be an implementation- and locale-defined calendar type that is one of the values returned from AvailableCalendars.</ins>
          1. <ins>Set _resolvedCalendar_ to CanonicalizeUValue(*"ca"*, _fallbackCalendar_).</ins>
          1. <ins>If the ECMAScript implementation has a mechanism for reporting diagnostic warning messages, a warning should be issued.</ins>
        1. Set _dateTimeFormat_.[[Calendar]] to _resolvedCalendar_.
        1. NOTE: Rest of algorithm unchanged.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-ecma402-properties-of-intl-datetimeformat-constructor">
    <h1>Properties of the Intl.DateTimeFormat Constructor</h1>

    <emu-clause id="sec-ecma402-intl.datetimeformat-internal-slots">
      <h1>Internal slots</h1>

      <p>[...]</p>

      <p>The value of the [[LocaleData]] internal slot is implementation-defined within the constraints described in <emu-xref href="#sec-internal-slots"></emu-xref> and the following additional constraints, for all locale values _locale_:</p>

      <ul>
        <li><ins>[[LocaleData]].[[&lt;_locale_>]].[[ca]] must be a List consisting of calendar types. Specifically, even if supporting only the calendars from <emu-xref href="#table-calendar-types"></emu-xref>, the list may also include *"islamic"* and *"islamic-rgsa"*.</ins></li>
        <li>
          [[LocaleData]].[[&lt;_locale_>]].[[nu]] must be a List that does not include the values *"native"*, *"traditio"*, or *"finance"*.
        </li>
        <li>
          [[LocaleData]].[[&lt;_locale_>]].[[hc]] must be « *null*, *"h11"*, *"h12"*, *"h23"*, *"h24"* ».
        </li>
        <li>[...]</li>
      </ul>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="ecma402-locale-sensitive-functions">
  <h1>Locale Sensitive Functions of the ECMAScript Language Specification</h1>

  <emu-clause id="sec-calendar-abstract-ops">
    <h1>Abstract Operations for Calendar Calculations</h1>

    <emu-clause id="sec-temporal-calendarsupportsera" type="abstract operation">
      <h1>
        CalendarSupportsEra (
          _calendar_: a calendar type,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The following algorithm refers (via <emu-xref href="#table-eras"></emu-xref>) to the era data from <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Data">UTS 35's Supplemental Calendar Data</a>.
        </dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is listed in the "Calendar" column of <emu-xref href="#table-eras"></emu-xref>, return *true*.
        1. If _calendar_ is listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>, return *false*.
        1. Return an implementation-defined value.
      </emu-alg>
      <p>
        <emu-xref href="#table-eras"></emu-xref> lists all currently known eras for the current set of calendars, including their aliases, ranges, and kinds.
        The canonical source for this table is the data described in <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Data">Unicode Technical Standard #35 Part 4 Dates, Calendar Data</a>.
      </p>
      <p>The era kind is used by <emu-xref href="#sec-temporal-calendardatearithmeticyearforerayear">CalendarDateArithmeticYearForEraYear</emu-xref> to calculate the arithmetic year ([[Year]]):
      An *Era Kind* ~epoch~ means that the era is the epoch era, so 1 Era has an arithmetic year of 1. An *Era Kind* ~negative~ means that the era is a "negative" era growing
      from the epoch, so 1 Era is an arithmetic year of 0, and larger [[EraYear]] values produce smaller, negative arithmetic years. An *Era Kind* of
      ~offset~ means that the era is "offset" by a given number (in the *Offset* column), so 1 Era has an arithmetic year of *Offset*.</p>
      <emu-table id="table-eras">
        <emu-caption>Eras</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Calendar</th>
              <th>Era</th>
              <th>Aliases</th>
              <th>Minimum eraYear</th>
              <th>Maximum eraYear</th>
              <th>Era Kind</th>
              <th>Offset</th>
            </tr>
          </thead>
          <tr>
            <td>*"buddhist"*</td>
            <td>*"be"*</td>
            <td></td>
            <td>-∞</td>
            <td>+∞</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"coptic"*</td>
            <td>*"am"*</td>
            <td></td>
            <td>-∞</td>
            <td>+∞</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"ethioaa"*</td>
            <td>*"aa"*</td>
            <td></td>
            <td>-∞</td>
            <td>+∞</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"ethiopic"*</td>
            <td>*"am"*</td>
            <td></td>
            <td>1</td>
            <td>+∞</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"ethiopic"*</td>
            <td>*"aa"*</td>
            <td></td>
            <td>-∞</td>
            <td>5500</td>
            <td> ~offset~</td>
            <td>-5499</td>
          </tr>
          <tr>
            <td>*"gregory"*</td>
            <td>*"ce"*</td>
            <td>*"ad"*</td>
            <td>1</td>
            <td>+∞</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"gregory"*</td>
            <td>*"bce"*</td>
            <td>*"bc"*</td>
            <td>1</td>
            <td>+∞</td>
            <td>~negative~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"hebrew"*</td>
            <td>*"am"*</td>
            <td></td>
            <td>-∞</td>
            <td>+∞</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"indian"*</td>
            <td>*"shaka"*</td>
            <td></td>
            <td>-∞</td>
            <td>+∞</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"islamic-civil"*</td>
            <td>*"ah"*</td>
            <td></td>
            <td>1</td>
            <td>+∞</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"islamic-civil"*</td>
            <td>*"bh"*</td>
            <td></td>
            <td>1</td>
            <td>+∞</td>
            <td>~negative~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"islamic-tbla"*</td>
            <td>*"ah"*</td>
            <td></td>
            <td>1</td>
            <td>+∞</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"islamic-tbla"*</td>
            <td>*"bh"*</td>
            <td></td>
            <td>1</td>
            <td>+∞</td>
            <td>~negative~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"islamic-umalqura"*</td>
            <td>*"ah"*</td>
            <td></td>
            <td>1</td>
            <td>+∞</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"islamic-umalqura"*</td>
            <td>*"bh"*</td>
            <td></td>
            <td>1</td>
            <td>+∞</td>
            <td>~negative~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"reiwa"*</td>
            <td></td>
            <td>1</td>
            <td>+∞</td>
            <td>~offset~</td>
            <td>2019</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"heisei"*</td>
            <td></td>
            <td>1</td>
            <td>31</td>
            <td>~offset~</td>
            <td>1989</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"showa"*</td>
            <td></td>
            <td>1</td>
            <td>64</td>
            <td>~offset~</td>
            <td>1926</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"taisho"*</td>
            <td></td>
            <td>1</td>
            <td>15</td>
            <td>~offset~</td>
            <td>1912</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"meiji"*</td>
            <td></td>
            <td>1</td>
            <td>45</td>
            <td>~offset~</td>
            <td>1868</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"ce"*</td>
            <td>*"ad"*</td>
            <td>1</td>
            <td>1868</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>*"bce"*</td>
            <td>*"bc"*</td>
            <td>1</td>
            <td>+∞</td>
            <td>~negative~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"persian"*</td>
            <td>*"ap"*</td>
            <td></td>
            <td>-∞</td>
            <td>+∞</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"roc"*</td>
            <td>*"roc"*</td>
            <td></td>
            <td>1</td>
            <td>+∞</td>
            <td>~epoch~</td>
            <td></td>
          </tr>
          <tr>
            <td>*"roc"*</td>
            <td>*"broc"*</td>
            <td></td>
            <td>1</td>
            <td>+∞</td>
            <td>~negative~</td>
            <td></td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-canonicalizeeraincalendar" type="abstract operation">
      <h1>
        CanonicalizeEraInCalendar (
          _calendar_: a calendar type that is not *"iso8601"*,
          _era_: a String,
        ): a String or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The following algorithm refers to the era data from <a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Data">UTS 35's Supplemental Calendar Data</a>.
        </dd>
      </dl>
      <emu-alg>
        1. For each row of <emu-xref href="#table-eras"></emu-xref>, except the header row, do
          1. Let _cal_ be the Calendar value of the current row.
          1. If _cal_ is equal to _calendar_, then
            1. Let _canonicalName_ be the Era value of the current row.
            1. If _canonicalName_ is equal to _era_, return _canonicalName_.
            1. Let _aliases_ be a List whose elements are the strings given in the "Aliases" column of the row.
            1. If _aliases_ contains _era_, return _canonicalName_.
        1. If _calendar_ is listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>, return *undefined*.
        1. Return an implementation-defined value.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarhasmidyeareras" type="abstract operation">
      <h1>
        CalendarHasMidYearEras (
          _calendar_: a calendar type that is not *"iso8601"*,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It returns *true* if the calendar has eras that start in the middle of the year, or *false* if all eras start on a year boundary.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is *"japanese"*, return *true*.
        1. If _calendar_ is listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>, return *false*.
        1. Return an implementation-defined value.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-isvalidmonthcodeforcalendar" type="abstract operation">
      <h1>
        IsValidMonthCodeForCalendar (
          _calendar_: a calendar type that is not *"iso8601"*,
          _monthCode_: a month code,
        ): a Boolean
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _commonMonthCodes_ be « *"M01"*, *"M02"*, *"M03"*, *"M04"*, *"M05"*, *"M06"*, *"M07"*, *"M08"*, *"M09"*, *"M10"*, *"M11"*, *"M12"* ».
        1. If _commonMonthCodes_ contains _monthCode_, return *true*.
        1. If _calendar_ is listed in the "Calendar" column of <emu-xref href="#table-additional-month-codes"></emu-xref>, then
          1. Let _r_ be the row in <emu-xref href="#table-additional-month-codes"></emu-xref> with a value in the Calendar column matching _calendar_.
          1. Let _specialMonthCodes_ be a List whose elements are the strings given in the "Additional Month Codes" column of _r_.
          1. If _specialMonthCodes_ contains _monthCode_, return *true*.
          1. Return *false*.
        1. If _calendar_ is listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>, return *false*.
        1. Return an implementation-defined value.
      </emu-alg>

      <emu-table id="table-additional-month-codes">
        <emu-caption>Additional Month Codes in Calendars</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Calendar</th>
              <th>Additional Month Codes</th>
              <th>Leap to Common Month Transformation</th>
            </tr>
          </thead>
          <tr>
            <td>*"chinese"*</td>
            <td>*"M01L"*, *"M02L"*, *"M03L"*, *"M04L"*, *"M05L"*, *"M06L"*, *"M07L"*, *"M08L"*, *"M09L"*, *"M10L"*, *"M11L"*, *"M12L"*</td>
            <td>~skip-backward~</td>
          </tr>
          <tr>
            <td>*"coptic"*</td>
            <td>*"M13"*</td>
            <td></td>
          </tr>
          <tr>
            <td>*"dangi"*</td>
            <td>*"M01L"*, *"M02L"*, *"M03L"*, *"M04L"*, *"M05L"*, *"M06L"*, *"M07L"*, *"M08L"*, *"M09L"*, *"M10L"*, *"M11L"*, *"M12L"*</td>
            <td>~skip-backward~</td>
          </tr>
          <tr>
            <td>*"ethioaa"*</td>
            <td>*"M13"*</td>
            <td></td>
          </tr>
          <tr>
            <td>*"ethiopic"*</td>
            <td>*"M13"*</td>
            <td></td>
          </tr>
          <tr>
            <td>*"hebrew"*</td>
            <td>*"M05L"*</td>
            <td>~skip-forward~</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-yearcontainsmonthcode" type="implementation-defined abstract operation">
      <h1>
        YearContainsMonthCode (
          _calendar_: a calendar type that is not *"iso8601"*,
          _arithmeticYear_: an integer,
          _monthCode_: a month code,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns whether the given _monthCode_ exists in _arithmeticYear_ of _calendar_.
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: IsValidMonthCodeForCalendar(_calendar_, _monthCode_) is *true*.
        1. If ! ParseMonthCode(_monthCode_).[[IsLeap]] is *false*, return *true*.
        1. Return whether the leap month indicated by _monthCode_ exists in the year _arithmeticYear_ in _calendar_, using calendar-dependent behaviour.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-constrainmonthcode" type="abstract operation">
      <h1>
        ConstrainMonthCode (
          _calendar_: a calendar type that is not *"iso8601"*,
          _arithmeticYear_: an integer,
          _monthCode_: a month code,
          _overflow_: ~constrain~ or ~reject~,
        ): either a normal completion containing a month code or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns the month code in _arithmeticYear_ of _calendar_ that best matches the given _monthCode_. If _monthCode_ does not exist in _arithmeticYear_, it is constrained to the best common month if _overflow_ is ~constrain~, or an error is thrown if _overflow_ is ~reject~.
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: IsValidMonthCodeForCalendar(_calendar_, _monthCode_) is *true*.
        1. If YearContainsMonthCode(_calendar_, _arithmeticYear_, _monthCode_) is *true*, return _monthCode_.
        1. If _overflow_ is ~reject~, throw a *RangeError* exception.
        1. If _calendar_ is not listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>, return an implementation-defined value.
        1. Assert: _calendar_ is listed in the "Calendar" column of <emu-xref href="#table-additional-month-codes"></emu-xref>.
        1. Let _r_ be the row in <emu-xref href="#table-additional-month-codes"></emu-xref> with a value in the Calendar column matching _calendar_.
        1. Let _shiftType_ be the value given in the "Leap to Common Month Tranformation" column of _r_.
        1. If _shiftType_ is ~skip-backward~, then
          1. Return CreateMonthCode(! ParseMonthCode(_monthCode_).[[MonthNumber]], *false*).
        1. Else,
          1. Assert: _monthCode_ is *"M05L"*.
          1. Return *"M06"*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-monthcodetoordinal" type="abstract operation">
      <h1>
        MonthCodeToOrdinal (
          _calendar_: a calendar type that is not *"iso8601"*,
          _arithmeticYear_: an integer,
          _monthCode_: a month code,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns the ordinal month number for _monthCode_ in _arithmeticYear_ of _calendar_. The given _monthCode_ must exist in the given year.
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Assert: YearContainsMonthCode(_calendar_, _arithmeticYear_, _monthCode_) is *true*.
        1. Let _monthsBefore_ be 0.
        1. Let _number_ be 1.
        1. Let _isLeap_ be *false*.
        1. If _calendar_ is not listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>, return an implementation-defined value.
        1. Let _r_ be the row in <emu-xref href="#table-additional-month-codes"></emu-xref> with a value in the Calendar column matching _calendar_.
        1. If the "Leap to Common Month Tranformation" column of _r_ is empty, then
          1. Return ! ParseMonthCode(_monthCode_).[[MonthNumber]].
        1. Assert: The "Additional Month Codes" column of _r_ does not contain *"M00L"* or *"M13"*.
        1. Assert: The following loop will terminate.
        1. Repeat, while _number_ &le; 12,
          1. Let _currentMonthCode_ be CreateMonthCode(_number_, _isLeap_).
          1. If YearContainsMonthCode(_calendar_, _arithmeticYear_, _currentMonthCode_), then
            1. Set _monthsBefore_ to _monthsBefore_ + 1.
          1. If _currentMonthCode_ is _monthCode_, then
            1. Return _monthsBefore_.
          1. If _isLeap_ is *false*, then
            1. Set _isLeap_ to *true*.
          1. Else,
            1. Set _isLeap_ to *false*.
            1. Set _number_ to _number_ + 1.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardaysinmonth" type="implementation-defined abstract operation">
      <h1>
        CalendarDaysInMonth (
          _calendar_: a calendar type that is not *"iso8601"*,
          _arithmeticYear_: an integer,
          _ordinalMonth_: a positive integer,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns the number of days in the _calendar_-specific _arithmeticYear_ and _ordinalMonth_.
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Return the number of days in the month of _calendar_ corresponding to _arithmeticYear_ and _ordinalMonth_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateera" type="abstract operation">
      <h1>
        CalendarDateEra (
          _calendar_: a calendar type that is not *"iso8601"*,
          _date_: an ISO Date Record,
        ): a String or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the era for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns a lowercase String value representing that era, or *undefined* for calendars that do not have eras.</dd>
      </dl>
      <emu-alg>
        1. If CalendarSupportsEra(_calendar_) is *false*, return *undefined*.
        1. Let _era_ be the String to indicate the era corresponding to _date_ in the context of the calendar represented by _calendar_ according to implementation-defined processing.
        1. Return CanonicalizeEraInCalendar(_calendar_, _era_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardateerayear" type="abstract operation">
      <h1>
        CalendarDateEraYear (
          _calendar_: a calendar type that is not *"iso8601"*,
          _date_: an ISO Date Record,
        ): an integer or *undefined*
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the era for the date corresponding to _date_ in the context of the calendar represented by _calendar_ and returns an integer representing the ordinal position of the year of _date_ in that era, or *undefined* for calendars that do not have eras.</dd>
      </dl>
      </dl>
      <emu-alg>
        1. If CalendarSupportsEra(_calendar_) is *false*, return *undefined*.
        1. Let _eraYear_ be the integer to indicate the era year corresponding to _date_ in the context of the calendar represented by _calendar_ according to implementation-defined processing.
        1. Assert: _eraYear_ is an integer.
        1. Return _eraYear_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatearithmeticyear" type="abstract operation">
      <h1>
        CalendarDateArithmeticYear (
          _calendar_: a calendar type that is not *"iso8601"*,
          _date_: an ISO Date Record,
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It performs implementation-defined processing to find the arithmetic year for the date corresponding to _date_ in the context of the calendar represented by _calendar_.</dd>
      </dl>
      <emu-alg>
        1. If _calendar_ is not listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>, return an implementation-defined value.
        1. Let _r_ be the row in <emu-xref href="#table-epoch-years"></emu-xref> with a value in the Calendar column matching _calendar_.
        1. Let _epochYear_ be the value given in the "Epoch ISO Year" column of _r_.
        1. Let _epochDate_ be the first day of the calendar year starting in ISO year _epochYear_ in the calendar represented by _calendar_, according to implementation-defined processing.
        1. Let _newYear_ be the first day of the calendar year of _date_ in the calendar represented by _calendar_, according to implementation-defined processing.
        1. Let _arithmeticYear_ be the number of whole years between _epochDate_ and _newYear_ in the calendar represented by _calendar_, according to implementation-defined processing.
        1. Return _arithmeticYear_.
      </emu-alg>

      <emu-table id="table-epoch-years">
        <emu-caption>Epoch years</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Calendar</th>
              <th>Epoch ISO Year</th>
            </tr>
          </thead>
          <tr>
            <td>*"buddhist"*</td>
            <td>-543</td>
          </tr>
          <tr>
            <td>*"chinese"*</td>
            <td>0</td>
          </tr>
          <tr>
            <td>*"coptic"*</td>
            <td>283</td>
          </tr>
          <tr>
            <td>*"dangi"*</td>
            <td>0</td>
          </tr>
          <tr>
            <td>*"ethioaa"*</td>
            <td>-5493</td>
          </tr>
          <tr>
            <td>*"ethiopic"*</td>
            <td>7</td>
          </tr>
          <tr>
            <td>*"gregory"*</td>
            <td>0</td>
          </tr>
          <tr>
            <td>*"hebrew"*</td>
            <td>-3761</td>
          </tr>
          <tr>
            <td>*"indian"*</td>
            <td>78</td>
          </tr>
          <tr>
            <td>*"islamic-civil"*</td>
            <td>621</td>
          </tr>
          <tr>
            <td>*"islamic-tbla"*</td>
            <td>621</td>
          </tr>
          <tr>
            <td>*"islamic-umalqura"*</td>
            <td>621</td>
          </tr>
          <tr>
            <td>*"japanese"*</td>
            <td>0</td>
          </tr>
          <tr>
            <td>*"persian"*</td>
            <td>621</td>
          </tr>
          <tr>
            <td>*"roc"*</td>
            <td>1911</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-calendardatearithmeticyearforerayear" type="abstract operation">
      <h1>
        CalendarDateArithmeticYearForEraYear (
          _calendar_: a calendar type that has eras,
          _era_: a String,
          _eraYear_: an integer
        ): an integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It produces the arithmetic year for a given set of _era_, _eraYear_ in _calendar_, a calendar that includes an era named _era_.</dd>
      </dl>
      <emu-alg>
        1. Let _era_ be CanonicalizeEraInCalendar(_calendar_, _era_).
        1. Assert: _era_ is not *undefined*.
        1. If _calendar_ is not listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>, return an implementation-defined value.
        1. Let _r_ be the row in <emu-xref href="#table-eras"></emu-xref> with a value in the Calendar column matching _calendar_ and a value in the Era column matching _era_.
        1. Let _eraKind_ be the value given in the "Era Kind" column of _r_.
        1. Let _offset_ be the value given in the "Offset" column of _r_.
        1. If _eraKind_ is ~epoch~, return _eraYear_.
        1. If _eraKind_ is ~negative~, return <emu-eqn>1 - _eraYear_</emu-eqn>.
        1. Assert: _eraKind_ is ~offset~.
        1. Assert: _offset_ is not *undefined*.
        1. Return <emu-eqn>_offset_ + _eraYear_ - 1</emu-eqn>.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarintegerstoiso" type="implementation-defined abstract operation">
      <h1>
        CalendarIntegersToISO (
          _calendar_: a calendar type that is not *"iso8601"*,
          _arithmeticYear_: an integer,
          _ordinalMonth_: a positive integer,
          _day_: a positive integer,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It returns an ISO Date Record that corresponds with the given _calendar_-specific _arithmeticYear_, _ordinalMonth_, and _day_.
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. If _arithmeticYear_, _ordinalMonth_, and _day_ do not form a valid date in _calendar_, throw a *RangeError* exception.
        1. Let _isoDate_ be an ISO Date Record such that CalendarISOToDate(_calendar_, _isoDate_) returns a Calendar Date Record whose [[Year]], [[Month]], and [[Day]] field values respectively equal _arithmeticYear_, _ordinalMonth_, and _day_.
        1. Return _isoDate_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-temporal-calendar-date-records">
      <h1>Calendar Date Records</h1>
      <p>
        A <dfn variants="Calendar Date Records">Calendar Date Record</dfn> is a Record value used to represent a valid calendar date in a non-ISO 8601 calendar.
        Calendar Date Records are produced by the abstract operation CalendarISOToDate.
      </p>
      <p>Calendar Date Records have the fields listed in <emu-xref href="#table-temporal-calendar-date-record-fields"></emu-xref>.</p>
      <p>This definition supersedes the one in <emu-xref href="#sec-temporal-calendar-date-records"></emu-xref>.</p>
      <emu-table id="table-temporal-calendar-date-record-fields" caption="Calendar Date Record Fields">
        <table class="real-table">
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Era]]</td>
            <td>a String or *undefined*</td>
            <td>
              A lowercase String value representing the date's era, or *undefined* for calendars that do not have eras.<br>
              The value of this field for a calendar type _calendar_ should be the result of calling CalendarDateEra(_calendar_, _date_), where _date_ is the [[ISODate]] field of a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth value corresponding to the date.
            </td>
          </tr>
          <tr>
            <td>[[EraYear]]</td>
            <td>an integer or *undefined*</td>
            <td>
              The ordinal position of the date's year within its era, or *undefined* for calendars that do not have eras.<br>
              The value of this field for a calendar type _calendar_ should be the result of calling CalendarDateEraYear(_calendar_, _date_), where _date_ is the [[ISODate]] field of a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth value corresponding to the date.
              <emu-note>
                Era years are 1-indexed for many calendars, but not all (e.g., the eras of the Burmese calendar, not currently available in CLDR, each start with a year 0). Years can also advance opposite the flow of time (as for BCE years in the Gregorian calendar).
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[Year]]</td>
            <td>an integer</td>
            <td>
              The date's <dfn>arithmetic year</dfn>, which is the year relative to the first day of a calendar-specific <dfn>epoch year</dfn>, given in <emu-xref href="#table-epoch-years"></emu-xref>.<br>
              The value of this field for a calendar type _calendar_ should be the result of calling CalendarDateArithmeticYear(_calendar_, _date_), where _date_ is the [[ISODate]] field of a Temporal.PlainDateTime, Temporal.PlainDate, or Temporal.PlainYearMonth value corresponding to the date.
              <emu-note>The arithmetic year is relative to the first day of the calendar's epoch year, so if the epoch era starts in the middle of the year, the year will be the same value before and after the start date of the era.</emu-note>
            </td>
          </tr>
          <tr>
            <td>[[Month]]</td>
            <td>a positive integer</td>
            <td>
              The 1-based ordinal position of the date's month within its year.
              <emu-note>
                When the number of months in a year of the calendar is variable, a different value can be returned for dates that are part of the same month in different years. For example, in the Hebrew calendar, 1 Nisan 5781 is associated with value 7 while 1 Nisan 5782 is associated with value 8 because 5782 is a leap year and Nisan follows the insertion of Adar I.
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[MonthCode]]</td>
            <td>a String</td>
            <td>
              The month code of the date's month. The month code for a month that is not a leap month and whose 1-based ordinal position in a common year of the calendar (i.e., a year that is not a leap year) is _n_ should be the string-concatenation of *"M"* and ToZeroPaddedDecimalString(_n_, 2), and the month code for a month that is a leap month inserted after a month whose 1-based ordinal position in a common year of the calendar is _p_ should be the string-concatenation of *"M"*, ToZeroPaddedDecimalString(_p_, 2), and *"L"*.
              <emu-note>
                For example, in the Hebrew calendar, the month code of Adar (and Adar II, in leap years) is *"M06"* and the month code of Adar I (the leap month inserted before Adar II) is *"M05L"*. Theoretically, in a calendar with a leap month at the start of some years, the month code of that month would be *"M00L"*.
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[Day]]</td>
            <td>a positive integer</td>
            <td>
              The 1-based ordinal position of the date's day within its month.
            </td>
          </tr>
          <tr>
            <td>[[DayOfWeek]]</td>
            <td>a positive integer</td>
            <td>
              The day of the week corresponding to the date. The value should be 1-based, where 1 is the day corresponding to Monday in the given calendar.
            </td>
          </tr>
          <tr>
            <td>[[DayOfYear]]</td>
            <td>a positive integer</td>
            <td>
              The 1-based ordinal position of the date's day within its year.
            </td>
          </tr>
          <tr>
            <td>[[WeekOfYear]]</td>
            <td>a Year-Week Record</td>
            <td>
              <p>The date's <em>calendar week of year</em>, and the corresponding <em>week calendar year</em>.</p>
              <p>The Year-Week Record's [[Week]] field should be 1-based.</p>
              <p>The Year-Week Record's [[Year]] field is an arithmetic year as in the Calendar Date Record's [[Year]] field, not relative to an era as in [[EraYear]].</p>
              <p>
                Usually the Year-Week Record's [[Year]] field will contain the same value as the Calendar Date Record's [[Year]] field, but may contain the previous or next year if the week number in the Year-Week Record's [[Week]] field overlaps two different years.
                See also ISOWeekOfYear.
              </p>
              <p>The Year-Week Record contains *undefined* in [[Week]] and [[Year]] field for calendars that do not have a well-defined week numbering system.</p>
              <emu-note>
                Currently, of the calendars supported in this specification, only *"iso8601"* has a well-defined, locale-independent week numbering system.
                For all other calendars, the Year-Week Record fields are *undefined*.
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[DaysInWeek]]</td>
            <td>a positive integer</td>
            <td>
              <p>The number of days in the primary notion of week used by the calendar. For all calendars currently supported by this specification, this number is 7.</p>
              <emu-note>
                Some calendars have alternate cyclic notions that are similar to the 7-day week; many of them have multiple (like the Javanese calendar). This specification does not cover such calendars but can be extended to do so in the future.
              </emu-note>
            </td>
          </tr>
          <tr>
            <td>[[DaysInMonth]]</td>
            <td>a positive integer</td>
            <td>The number of days in the date's month.</td>
          </tr>
          <tr>
            <td>[[DaysInYear]]</td>
            <td>a positive integer</td>
            <td>The number of days in the date's year.</td>
          </tr>
          <tr>
            <td>[[MonthsInYear]]</td>
            <td>a positive integer</td>
            <td>The number of months in the date's year.</td>
          </tr>
          <tr>
            <td>[[InLeapYear]]</td>
            <td>a Boolean</td>
            <td>
              *true* if the date falls within a leap year, and *false* otherwise.
              <emu-note>
                A "leap year" is a year that contains more days than other years (for solar or lunar calendars) or more months than other years (for lunisolar calendars like Hebrew or Chinese).
                Some calendars, especially lunisolar ones, have further variation in year length that is not represented in the output of this operation (e.g., the Hebrew calendar includes common years with 353, 354, or 355 days and leap years with 383, 384, or 385 days).
              </emu-note>
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-calendarmonthsinyear" type="implementation-defined abstract operation">
      <h1>
        CalendarMonthsInYear (
          _calendar_: a calendar type that is not *"iso8601"*,
          _arithmeticYear_: an integer,
        ): a positive integer
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It interprets _arithmeticYear_ as a year in the given calendar in the same way as CalendarDateArithmeticYear, and returns the number of months in that year.
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Return the number of months in arithmetic year _arithmeticYear_ of calendar _calendar_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-balancenonisodate" type="implementation-defined abstract operation">
      <h1>
        BalanceNonISODate (
          _calendar_: a calendar type that is not *"iso8601"*,
          _arithmeticYear_: an integer,
          _ordinalMonth_: a positive integer,
          _day_: an integer,
        ): a Record with fields [[Year]] (an integer), [[Month]] (a positive integer), and [[Day]] (a positive integer)
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It interprets the given _arithmeticYear_, potentially out-of-range _ordinalMonth_, and potentially out-of-range _day_ as arithmetical values in the given _calendar_ and returns in-range values by overflowing out-of-range _ordinalMonth_ or _day_ values into the next-highest unit.
          This date may correspond to a date in the ISO calendar that is outside the range given by ISODateTimeWithinLimits.
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _resolvedYear_ be _arithmeticYear_.
        1. Let _resolvedMonth_ be _ordinalMonth_.
        1. Let _monthsInYear_ be CalendarMonthsInYear(_calendar_, _resolvedYear_).
        1. Repeat, while _resolvedMonth_ &le; 0,
          1. Set _resolvedYear_ to _resolvedYear_ - 1.
          1. Set _monthsInYear_ to CalendarMonthsInYear(_calendar_, _resolvedYear_).
          1. Set _resolvedMonth_ to _resolvedMonth_ + _monthsInYear_.
        1. Repeat, while _resolvedMonth_ &gt; _monthsInYear_,
          1. Set _resolvedMonth_ to _resolvedMonth_ - _monthsInYear_.
          1. Set _resolvedYear_ to _resolvedYear_ + 1.
          1. Set _monthsInYear_ to CalendarMonthsInYear(_calendar_, _resolvedYear_).
        1. Let _resolvedDay_ be _day_.
        1. Let _daysInMonth_ be CalendarDaysInMonth(_calendar_, _resolvedYear_, _resolvedMonth_).
        1. Repeat, while _resolvedDay_ &le; 0,
          1. Set _resolvedMonth_ to _resolvedMonth_ - 1.
          1. If _resolvedMonth_ is 0, then
            1. Set _resolvedYear_ to _resolvedYear_ - 1.
            1. Set _monthsInYear_ to CalendarMonthsInYear(_calendar_, _resolvedYear_).
            1. Set _resolvedMonth_ to _monthsInYear_.
          1. Set _daysInMonth_ to CalendarDaysInMonth(_calendar_, _resolvedYear_, _resolvedMonth_).
          1. Set _resolvedDay_ to _resolvedDay_ + _daysInMonth_.
        1. Repeat, while _resolvedDay_ &gt; _daysInMonth_,
          1. Set _resolvedDay_ to _resolvedDay_ - _daysInMonth_.
          1. Set _resolvedMonth_ to _resolvedMonth_ + 1.
          1. If _resolvedMonth_ &gt; _monthsInYear_, then
            1. Set _resolvedYear_ to _resolvedYear_ + 1.
            1. Set _monthsInYear_ to CalendarMonthsInYear(_calendar_, _resolvedYear_).
            1. Set _resolvedMonth_ to 1.
          1. Set _daysInMonth_ to CalendarDaysInMonth(_calendar_, _resolvedYear_, _resolvedMonth_).
        1. Return the Record { [[Year]]: _resolvedYear_, [[Month]]: _resolvedMonth_, [[Day]]: _resolvedDay_ }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-nonisodatesurpasses" type="implementation-defined abstract operation">
      <h1>
        NonISODateSurpasses (
          _calendar_: a calendar type that is not *"iso8601"*,
          _sign_: -1 or 1,
          _fromIsoDate_: an ISO Date Record,
          _toIsoDate_: an ISO Date Record,
          _years_: an integer,
          _months_: an integer,
          _weeks_: an integer,
          _days_: an integer,
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The return value indicates whether the date _date1_, the result of adding the duration denoted by _years_, _months_, _weeks_, and _days_ to _fromIsoDate_ in the calendar system denoted by _calendar_, surpasses _toIsoDate_ in the direction denoted by _sign_.
          If _weeks_ and _days_ are both zero, then _date1_ need not exist (for example, it could be February 30).
        </dd>
      </dl>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _parts_ be CalendarISOToDate(_calendar_, _fromIsoDate_).
        1. Let _y0_ be _parts_.[[Year]] + _years_.
        1. Let _m0_ be MonthCodeToOrdinal(_calendar_, _y0_, ! ConstrainMonthCode(_calendar_, _y0_, _parts_.[[MonthCode]], ~constrain~)).
        1. Let _endOfMonth_ be BalanceNonISODate(_calendar_, _y0_, _m0_ + _months_ + 1, 0).
        1. Let _baseDay_ be _parts_.[[Day]].
        1. If _weeks_ is not 0 or _days_ is not 0, then
          1. If _baseDay_ &lt; _endOfMonth_.[[Day]], then
            1. Let _regulatedDay_ be _baseDay_.
          1. Else,
            1. Let _regulatedDay_ be _endOfMonth_.[[Day]].
          1. Let _daysInWeek_ be 7 (the number of days in a week for all supported calendars).
          1. Let _balancedDate_ be BalanceNonISODate(_calendar_, _endOfMonth_.[[Year]], _endOfMonth_.[[Month]], _regulatedDay_ + _daysInWeek_ * _weeks_ + _days_).
          1. Let _y1_ be _balancedDate_.[[Year]].
          1. Let _m1_ be _balancedDate_.[[Month]].
          1. Let _d1_ be _balancedDate_.[[Day]].
        1. Else,
          1. Let _y1_ be _endOfMonth_.[[Year]].
          1. Let _m1_ be _endOfMonth_.[[Month]].
          1. Let _d1_ be _baseDay_.
        1. Let _calDate2_ be CalendarISOToDate(_calendar_, _toIsoDate_).
        1. If _y1_ ≠ _calDate2_.[[Year]], then
          1. If _sign_ × (_y1_ - _calDate2_.[[Year]]) > 0, return *true*.
        1. Else if _m1_ ≠ _calDate2_.[[Month]], then
          1. If _sign_ × (_m1_ - _calDate2_.[[Month]]) > 0, return *true*.
        1. Else if _d1_ ≠ _calDate2_.[[Day]], then
          1. If _sign_ × (_d1_ - _calDate2_.[[Day]]) > 0, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-temporal-nonisodateadd" type="implementation-defined abstract operation">
      <h1>
        NonISODateAdd (
          _calendar_: a calendar type that is not *"iso8601"*,
          _isoDate_: an ISO Date Record,
          _duration_: a Date Duration Record,
          _overflow_: ~constrain~ or ~reject~,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          The operation performs implementation-defined processing to add _duration_ to _date_ in the context of the calendar represented by _calendar_ and returns the corresponding day, month and year of the result in the ISO 8601 calendar values as an ISO Date Record.
          It may throw a *RangeError* exception if _overflow_ is ~reject~ and the resulting month or day would need to be clamped in order to form a valid date in _calendar_.
        </dd>
      </dl>
      <p>All calendars follow the steps given here, which is a generalization of the precise algorithm specified in CalendarDateAdd for *"iso8601"*.</p>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal-nonisodateadd"></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _parts_ be CalendarISOToDate(_calendar_, _isoDate_).
        1. Let _y0_ be _parts_.[[Year]] + _duration_.[[Years]].
        1. Let _m0_ be MonthCodeToOrdinal(_calendar_, _y0_, ? ConstrainMonthCode(_calendar_, _y0_, _parts_.[[MonthCode]], _overflow_)).
        1. Let _endOfMonth_ be BalanceNonISODate(_calendar_, _y0_, _m0_ + _duration_.[[Months]] + 1, 0).
        1. Let _baseDay_ be _parts_.[[Day]].
        1. If _baseDay_ &lt; _endOfMonth_.[[Day]], then
          1. Let _regulatedDay_ be _baseDay_.
        1. Else,
          1. If _overflow_ is ~reject~, throw a *RangeError* exception.
          1. Let _regulatedDay_ be _endOfMonth_.[[Day]].
        1. Let _balancedDate_ be BalanceNonISODate(_calendar_, _endOfMonth_.[[Year]], _endOfMonth_.[[Month]], _regulatedDay_ + 7 * _duration_.[[Weeks]] + _duration_.[[Days]]).
        1. Let _result_ be ? CalendarIntegersToISO(_calendar_, _balancedDate_.[[Year]], _balancedDate_.[[Month]], _balancedDate_.[[Day]]).
        1. If ISODateWithinLimits(_result_) is *false*, throw a *RangeError* exception.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-temporal-nonisodateuntil" type="implementation-defined abstract operation">
      <h1>
        NonISODateUntil (
          _calendar_: a calendar type that is not *"iso8601"*,
          _one_: an ISO Date Record,
          _two_: an ISO Date Record,
          _largestUnit_: a date unit,
        ): a Date Duration Record
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to determine the difference between the dates _one_ and _two_ using the years, months, and weeks reckoning of _calendar_.
          No fields larger than _largestUnit_ will be non-zero in the resulting Date Duration Record.
        </dd>
      </dl>
      <p>All calendars follow the steps given here, which is a generalization of the precise algorithm specified in CalendarDateUntil for *"iso8601"*.</p>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal-nonisodateuntil"></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Let _sign_ be -1 × CompareISODate(_one_, _two_).
        1. If _sign_ = 0, return ZeroDateDuration().
        1. Let _years_ be 0.
        1. If _largestUnit_ is ~year~, then
          1. Let _candidateYears_ be _sign_.
          1. Repeat, while NonISODateSurpasses(_calendar_, _sign_, _one_, _two_, _candidateYears_, 0, 0, 0) is *false*,
            1. Set _years_ to _candidateYears_.
            1. Set _candidateYears_ to _candidateYears_ + _sign_.
        1. Let _months_ be 0.
        1. If _largestUnit_ is ~year~ or _largestUnit_ is ~month~, then
          1. Let _candidateMonths_ be _sign_.
          1. Repeat, while NonISODateSurpasses(_calendar_, _sign_, _one_, _two_, _years_, _candidateMonths_, 0, 0) is *false*,
            1. Set _months_ to _candidateMonths_.
            1. Set _candidateMonths_ to _candidateMonths_ + _sign_.
        1. Let _weeks_ be 0.
        1. If _largestUnit_ is ~week~, then
          1. Let _candidateWeeks_ be _sign_.
          1. Repeat, while NonISODateSurpasses(_calendar_, _sign_, _one_, _two_, _years_, _months_, _candidateWeeks_, 0) is *false*,
            1. Set _weeks_ to _candidateWeeks_.
            1. Set _candidateWeeks_ to _candidateWeeks_ + sign.
        1. Let _days_ be 0.
        1. Let _candidateDays_ be _sign_.
        1. Repeat, while NonISODateSurpasses(_calendar_, _sign_, _one_, _two_, _years_, _months_, _weeks_, _candidateDays_) is *false*,
          1. Set _days_ to _candidateDays_.
          1. Set _candidateDays_ to _candidateDays_ + _sign_.
        1. Return ! CreateDateDurationRecord(_years_, _months_, _weeks_, _days_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-temporal-nonisocalendardatetoiso" type="implementation-defined abstract operation">
      <h1>
        NonISOCalendarDateToISO (
          _calendar_: a calendar type that is not *"iso8601"*,
          _fields_: a Calendar Fields Record,
          _overflow_: ~constrain~ or ~reject~,
        ): either a normal completion containing an ISO Date Record or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to convert _fields_, which represents either a date or a year and month in the built-in calendar identified by _calendar_, to a corresponding representative date in the ISO 8601 calendar, subject to overflow correction specified by _overflow_.
          For ~reject~, values that do not form a valid date cause an exception to be thrown, as described below.
          For ~constrain~, values that do not form a valid date are clamped to their respective valid range.
        </dd>
      </dl>
      <p>Like RegulateISODate, the operation throws a *RangeError* exception when _overflow_ is ~reject~ and the date described by _fields_ does not exist.</p>
      <p>Clamping an invalid date to the correct range when _overflow_ is ~constrain~ is a behaviour specific to each calendar other than *"iso8601"*, but all calendars follow this guideline.</p>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal-nonisocalendardatetoiso"></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. If _fields_.[[Era]] and _fields_.[[EraYear]] are not ~unset~, then
          1. If CanonicalizeEraInCalendar(_calendar_, _fields_.[[Era]]) is *undefined*, throw a *RangeError* exception.
          1. Let _arithmeticYear_ be CalendarDateArithmeticYearForEraYear(_calendar_, _fields_.[[Era]], _fields_.[[EraYear]]).
        1. Else,
          1. Assert: _fields_.[[Year]] is not ~unset~.
          1. Let _arithmeticYear_ be _fields_.[[Year]].
        1. If _fields_.[[MonthCode]] is not ~unset~, then
          1. If IsValidMonthCodeForCalendar(_calendar_, _fields_.[[MonthCode]]) is *false*, throw a *RangeError* exception.
          1. Let _constrainedMonthCode_ be ? ConstrainMonthCode(_calendar_, _arithmeticYear_, _fields_.[[MonthCode]], _overflow_).
          1. Let _ordinalMonth_ be MonthCodeToOrdinal(_calendar_, _arithmeticYear_, _constrainedMonthCode_).
        1. Else,
          1. Assert: _fields_.[[Month]] is not ~unset~.
          1. Let _ordinalMonth_ be _fields_.[[Month]].
        1. Let _day_ be _fields_.[[Day]].
        1. Assert: _day_ is not ~unset~.
        1. Let _daysInMonth_ be CalendarDaysInMonth(_calendar_, _arithmeticYear_, _ordinalMonth_).
        1. If _daysInMonth_ &lt; _day_, then
          1. If _overflow_ is ~reject~, throw a *RangeError* exception.
          1. Let _regulatedDay_ be _daysInMonth_.
        1. Else,
          1. Assert: _day_ ≥ 1.
          1. Let _regulatedDay_ be _day_.
        1. Return ? CalendarIntegersToISO(_calendar_, _arithmeticYear_, _ordinalMonth_, _regulatedDay_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-temporal-calendarextrafields" type="implementation-defined abstract operation">
      <h1>
        CalendarExtraFields (
          _calendar_: a calendar type,
          _fields_: a List of values from the "Enumeration Key" column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>,
        ): a List of values from the "Enumeration Key" column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It characterizes calendar-specific fields that are relevant for the provided _fields_ in the built-in calendar identified by _calendar_.</dd>
      </dl>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal-calendarextrafields"></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. If _calendar_ is not listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>, return an implementation-defined value.
        1. If _fields_ contains an element equal to ~year~ and CalendarSupportsEra(_calendar_) is *true*, then
          1. Return « ~era~, ~era-year~ ».
        1. Return an empty List.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sup-temporal-nonisofieldkeystoignore" type="implementation-defined abstract operation">
      <h1>
        NonISOFieldKeysToIgnore (
          _calendar_: a calendar type that is not *"iso8601"*,
          _keys_: a List of values from the "Enumeration Key" column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>,
        ): a List of values from the "Enumeration Key" column of <emu-xref href="#table-temporal-calendar-fields-record-fields"></emu-xref>
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          It performs implementation-defined processing to determine which calendar date fields changing any of the fields named in _keys_ can potentially conflict with or invalidate, for the given _calendar_.
          A field always invalidates at least itself.
        </dd>
      </dl>
      <p>This definition supersedes the definition provided in <emu-xref href="#sec-temporal-nonisofieldkeystoignore"></emu-xref>.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. If _calendar_ is not listed in the "Calendar Type" column of <emu-xref href="#table-calendar-types"></emu-xref>, return an implementation-defined value.
        1. Let _ignoredKeys_ be a copy of _keys_.
        1. For each element _key_ of _keys_, do
          1. If _key_ is ~month~, append ~month-code~ to _ignoredKeys_.
          1. If _key_ is ~month-code~, append ~month~.
          1. If _key_ is one of ~era~, ~era-year~, or ~year~ and CalendarSupportsEra(_calendar_) is *true*, then
            1. Append ~era~, ~era-year~, and ~year~ to _ignoredKeys_.
          1. If _key_ is one of ~day~, ~month~, or ~month-code~ and CalendarHasMidYearEras(_calendar_) is *true*, then
            1. Append ~era~ and ~era-year~ to _ignoredKeys_.
        1. NOTE: While _ignoredKeys_ can have duplicate elements, this is not intended to be meaningful. This specification only checks whether particular keys are or are not members of the list.
        1. Return _ignoredKeys_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="normative-references">
  <h1>Normative References</h1>
  <p>The following referenced documents are required for the application of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</p>

  <p>
    ECMAScript 2026 Language Specification (<dfn id="ecma262">ECMA-262</dfn> 17<sup>th</sup> Edition, or successor).<br>
    <a href="https://www.ecma-international.org/publications/standards/Ecma-262.htm">https://www.ecma-international.org/publications/standards/Ecma-262.htm</a>
  </p>

  <ul>
    <li>
      ISO/IEC 10646:2014: Information Technology – Universal Multiple-Octet Coded Character Set (UCS) plus Amendment 1:2015 and Amendment 2, plus additional amendments and corrigenda, or successor
      <ul>
        <li><a href="https://www.iso.org/iso/catalogue_detail.htm?csnumber=63182">https://www.iso.org/iso/catalogue_detail.htm?csnumber=63182</a></li>
        <li><a href="https://www.iso.org/iso/catalogue_detail.htm?csnumber=65047">https://www.iso.org/iso/catalogue_detail.htm?csnumber=65047</a></li>
        <li><a href="https://www.iso.org/iso/catalogue_detail.htm?csnumber=66791">https://www.iso.org/iso/catalogue_detail.htm?csnumber=66791</a></li>
      </ul>
    </li>
    <li>
      <a href="https://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=64758">ISO 4217:2015, Codes for the representation of currencies and funds, or successor</a>
    </li>
    <li>
      <a href="https://tools.ietf.org/html/rfc4647">IETF RFC 4647, Matching of Language Tags, or successor</a>
    </li>
    <li>
      <a href="https://www.iana.org/time-zones/">IANA Time Zone Database</a>
    </li>
    <li>
      <a href="https://unicode.org/versions/latest">The Unicode Standard</a>
    </li>
    <li>
      <a href="https://unicode.org/reports/tr29/">Unicode Standard Annex #29: Unicode Text Segmentation</a>
    </li>
    <li>
      <a href="https://unicode.org/reports/tr10/">Unicode Technical Standard #10: Unicode Collation Algorithm</a>
    </li>
    <li>
      <a href="https://unicode.org/reports/tr35/">Unicode Technical Standard #35: Unicode Locale Data Markup Language (LDML)</a>
      <ul>
        <li>
          <a href="https://unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers">Part 1 Core, Section 3 Unicode Language and Locale Identifiers</a>
        </li>
        <li>
          <a href="https://unicode.org/reports/tr35/tr35-general.html#Unit_Identifiers">Part 2 General, Section 6.2 Unit Identifiers</a>
        </li>
        <li>
          <a href="https://unicode.org/reports/tr35/tr35-numbers.html#Operands">Part 3 Numbers, Section 5.1.1 Operands</a>
        </li>
        <li>
          <ins><a href="https://unicode.org/reports/tr35/tr35-dates.html#Calendar_Data">Part 4 Dates, Calendar Data</a></ins>
        </li>
      </ul>
    </li>
  </ul>
  <emu-note>
    Sections of this specification that depend on these references are updated on a best-effort basis, but are not guaranteed to be up-to-date with those standards.
  </emu-note>
</emu-clause>
